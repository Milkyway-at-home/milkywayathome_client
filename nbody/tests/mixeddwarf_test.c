/* This program tests the generation of dwarf galaxies. 
* Tests include:
* 1. Stability test
* 2. Virial Ratio Test
* 3. Center of Mass Test
*
* Dwarf galaxy types tested in this program:
* 1. Plummer
* 2. NFW
* 3. Hernquist
* 3. Plummer-Plummer
* 4. Plummer-NFW
* 5. Plummer-Hernquist
*
* Stability is determined by Kullback-Leibler divergence calculation of the theoretical probability density distribution
* and the normalized density distribution generated by MilkyWay@home.  
* Since the distribution of baryons and dark matter are determined separately, the program calculates the KL divergence for each component.
* If unstable, the generated density distribution tends to oscillate from looking stable to unstable.
* Because of this, the program calculates the KL divergence for each component at multiple time steps as to not accidentally conclude that an unstable system is stable.
*/

/* TODO:
* Change the lua file to use the get_soft_par() function to get the softening parameter instead of a hard coded value.
* Add Cored profile test.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include "nbody_mixeddwarf.h"
#include "nbody_particle_data.h"
#include "test_env_util.h"
#include "nbody_potential_types.h"

/* Dwarf galaxy parameters */
/* These scale radius and mass parameters are known in the group as Eric's parameters */
/* Optimized for a Plummer-Plummer model */
#define EVOLUTION_TIME "2.0"                  /* Evolution time in Gyr */
#define EVOLUTION_RATIO "0.0"                 /* Evolution time ratio */
#define BARYON_SCALE_RADIUS "0.181216"        /* Baryon Scale radius in kpc */
#define SCALE_RADIUS_RATIO "0.182799"         /* Scale radius ratio */
#define BARYON_MASS "1.22251"                 /* Baryon Mass in SMU */
#define MASS_RATIO "0.0126171"                /* Mass ratio */

/* KL divergence thresholds */
#define INITIAL_KL_THRESHOLD 0.01   /* Maximum acceptable initial KL divergence */
#define KL_FLUCTUATION_THRESHOLD 0.03 /* Maximum acceptable KL divergence fluctuation */

/* Struct to hold all simulation variables and allocations */
typedef struct {
    char* input_lua_file;
    real* baryon_bin_centers;
    real* dark_bin_centers;
    real* baryon_bin_edges;
    real* dark_bin_edges;
    real* baryon_theoretical_density;
    real* dark_theoretical_density;
    real* baryon_theoretical_probability;
    real* dark_theoretical_probability;
    real* baryon_simulation_density;
    real* dark_simulation_density;
    real* baryon_simulation_probability;
    real* dark_simulation_probability;
    ParticleCollection* particle_data;
    real nbody;
    real nbody_baryon;
    real nbody_dark;
    Dwarf *comp1;
    Dwarf *comp2;
    real timestep;
    real mass_per_particle_baryon;
    real mass_per_particle_dark;
    real baryon_bin_width;
    real dark_bin_width;
    int num_bins_baryon;
    int num_bins_dark;
    
} TestContext;

/* Clean all memory allocated by the program */
static void cleanup_all_memory(TestContext* tctx) {
    if (!tctx) return;
    if (tctx->input_lua_file) free(tctx->input_lua_file);
    if (tctx->baryon_bin_centers) free(tctx->baryon_bin_centers);
    if (tctx->dark_bin_centers) free(tctx->dark_bin_centers);
    if (tctx->baryon_bin_edges) free(tctx->baryon_bin_edges);
    if (tctx->dark_bin_edges) free(tctx->dark_bin_edges);
    if (tctx->baryon_theoretical_density) free(tctx->baryon_theoretical_density);
    if (tctx->dark_theoretical_density) free(tctx->dark_theoretical_density);
    if (tctx->baryon_theoretical_probability) free(tctx->baryon_theoretical_probability);
    if (tctx->dark_theoretical_probability) free(tctx->dark_theoretical_probability);
    if (tctx->baryon_simulation_density) free(tctx->baryon_simulation_density);
    if (tctx->dark_simulation_density) free(tctx->dark_simulation_density);
    if (tctx->baryon_simulation_probability) free(tctx->baryon_simulation_probability);
    if (tctx->dark_simulation_probability) free(tctx->dark_simulation_probability);
    if (tctx->particle_data) {
        free_particle_collection(tctx->particle_data);
        tctx->particle_data = NULL;
    }
    // Zero out pointers for safety
    memset(tctx, 0, sizeof(TestContext));
}

/* Calculate the mass enclosed within a given radius for a dwarf component */
static real mass_enclosed_function(const Dwarf *comp, real radius) {
    return 4.0 * M_PI * sqr(radius) * get_density(comp, radius);
}

/* Calculate the expected counts per bin for a given radius */
static real counts_per_bin(const Dwarf *comp, real radius, real mass_per_particle, real bin_width) {
    return mass_enclosed_function(comp, radius) * (1.0 / mass_per_particle) * bin_width;
}

/* Smooth and normalize a density distribution into a probability distribution */
static real* smooth_and_normalize_distribution(real* counts, size_t size) {   
    
    real epsilon = 1e-10;
    real sum = 0.0;
    real* normalized_counts = mwCallocA(size, sizeof(real));  

    // Add epsilon and calculate sum
    for (size_t i = 0; i < size; i++) {
        counts[i] += epsilon;
        sum += counts[i];
    }
        
    // Normalize the counts
    for (size_t i = 0; i < size; i++) {
        normalized_counts[i] = counts[i] / sum;
    }
    return normalized_counts;
}

/* Calculate the Kullback-Leibler divergence between two probability distributions */
static real kl_divergence(const real *p, const real *q, size_t size) {
    
    real kl_div = 0.0;
    
    for (size_t i = 0; i < size; i++) {
        kl_div += p[i] * mw_log(p[i] / q[i]);
    }
    
    return kl_div;
}

static real rice_rule(const real nbodies) {

    return (int)(2.0 * mw_pow(nbodies, 1.0/3.0));
}

/* Function for the stability test for a given dwarf potential type */
int test_stability(TestContext* tctx) {
    int failed = 0;
    printf("Starting stability test...\n");
    fflush(stdout);

    // Calculating the number of dark matter particles 
    tctx->nbody_dark = tctx->nbody - tctx->nbody_baryon;
    // Calculate the mass per particle for each component
    tctx->mass_per_particle_baryon = tctx->comp1->mass / tctx->nbody_baryon;
    tctx->mass_per_particle_dark = tctx->comp2->mass / tctx->nbody_dark;
    // Max radius range for calculation is either 4 times the scale length for plummer and general hernquist or 4 times the r200 for cored and nfw which is the radius bound
    real baryon_range_limit = (tctx->comp1->type == NFW || tctx->comp1->type == Cored) ? 4.0 * tctx->comp1->r200 : 4.0 * tctx->comp1->scaleLength;
    printf("Baryon range limit: %f\n", baryon_range_limit);
    real dark_range_limit = (tctx->comp2->type == NFW || tctx->comp2->type == Cored) ? 4.0 * tctx->comp2->r200 : 4.0 * tctx->comp2->scaleLength;
    printf("Dark matter range limit: %f\n", dark_range_limit);
    // Calculate the bin width for each component
    tctx->baryon_bin_width = baryon_range_limit / rice_rule(tctx->nbody_baryon);
    printf("Baryon bin width: %f\n", tctx->baryon_bin_width);
    tctx->dark_bin_width = dark_range_limit / rice_rule(tctx->nbody_dark);
    printf("Dark matter bin width: %f\n", tctx->dark_bin_width);
    // Calculate the number of bins for each component depending on the model type (+1 to include the last bin)
    tctx->num_bins_baryon = (int)((baryon_range_limit - tctx->baryon_bin_width) / tctx->baryon_bin_width) + 1;
    printf("Baryon number of bins: %d\n", tctx->num_bins_baryon);
    tctx->num_bins_dark = (int)((dark_range_limit - tctx->dark_bin_width) / tctx->dark_bin_width) + 1;
    printf("Dark matter number of bins: %d\n", tctx->num_bins_dark);
    printf("mass_per_particle_baryon: %f\n", tctx->mass_per_particle_baryon);
    printf("mass_per_particle_dark: %f\n", tctx->mass_per_particle_dark);
    printf("Baryon bin width: %f\n", tctx->baryon_bin_width);
    printf("Dark matter bin width: %f\n", tctx->dark_bin_width);
    printf("Using %d bins for baryon component and %d bins for dark matter component\n", tctx->num_bins_baryon, tctx->num_bins_dark);
    fflush(stdout);

    // Creating radius arrays for KL divergence calculation for each component (bin centers)
    tctx->baryon_bin_centers = mwCallocA(tctx->num_bins_baryon, sizeof(real));
    tctx->dark_bin_centers = mwCallocA(tctx->num_bins_dark, sizeof(real));

    // Create bin edges 
    tctx->baryon_bin_edges = mwCallocA(tctx->num_bins_baryon + 1, sizeof(real));
    tctx->dark_bin_edges = mwCallocA(tctx->num_bins_dark + 1, sizeof(real));

    // Initialize baryon bin edges
    for (int i = 0; i <= tctx->num_bins_baryon; i++) {
        tctx->baryon_bin_edges[i] = tctx->baryon_bin_width + i * tctx->baryon_bin_width;
    }

    // Initialize baryon bin centers
    for (int i = 0; i < tctx->num_bins_baryon; i++) {
        tctx->baryon_bin_centers[i] = tctx->baryon_bin_edges[i] + tctx->baryon_bin_width / 2.0;
    }
    
    // Initialize dark matter bin edges
    for (int i = 0; i <= tctx->num_bins_dark; i++) {
        tctx->dark_bin_edges[i] = tctx->dark_bin_width + i * tctx->dark_bin_width;
    }

    // Initialize dark matter bin centers
    for (int i = 0; i < tctx->num_bins_dark; i++) {
        tctx->dark_bin_centers[i] = tctx->dark_bin_edges[i] + tctx->dark_bin_width / 2.0;
    }
    
    // Calculate the theoretical density distribution for each component 
    tctx->baryon_theoretical_density = mwCallocA(tctx->num_bins_baryon, sizeof(real));
    tctx->dark_theoretical_density = mwCallocA(tctx->num_bins_dark, sizeof(real));

    // Calculate theoretical density for baryon component
    for (int i = 0; i < tctx->num_bins_baryon; i++) {
        tctx->baryon_theoretical_density[i] = counts_per_bin(tctx->comp1, tctx->baryon_bin_centers[i], 
                                         tctx->mass_per_particle_baryon, tctx->baryon_bin_width);
    }
    
    // Calculate theoretical density for dark matter component
    for (int i = 0; i < tctx->num_bins_dark; i++) {
        tctx->dark_theoretical_density[i] = counts_per_bin(tctx->comp2, tctx->dark_bin_centers[i], 
                                       tctx->mass_per_particle_dark, tctx->dark_bin_width);
    }
    
    // Normalize the theoretical densities and add epsilon to avoid division by zero and log(0) in KL divergence calculation
    tctx->baryon_theoretical_probability = smooth_and_normalize_distribution(tctx->baryon_theoretical_density, tctx->num_bins_baryon);
    tctx->dark_theoretical_probability = smooth_and_normalize_distribution(tctx->dark_theoretical_density, tctx->num_bins_dark);

    // Calculate the KL divergence at the initial timestep
    const char* initial_output_filename = "initial.out";
    printf("Checking for initial output file: %s\n", initial_output_filename);
    fflush(stdout);

    // Check if the initial output file exists
    if (access(initial_output_filename, F_OK) == -1) {
        fprintf(stderr, "Error: Initial output file '%s' does not exist\n", initial_output_filename);
        fflush(stdout);
        failed = 1;
        return failed;
    }

    // Read the initial output file
    tctx->particle_data = read_particle_file(initial_output_filename);
    if (!tctx->particle_data) {
        fprintf(stderr, "Error: Failed to read initial output file '%s'\n", initial_output_filename);
        fflush(stdout);
        failed = 1;
        return failed;
    }

    printf("Successfully read %zu particles from initial file\n", tctx->particle_data->count);
    fflush(stdout);
    
    // Validate particle count
    if (tctx->particle_data->count != (size_t)tctx->nbody) {
        fprintf(stderr, "Error: Expected %f particles but got %zu particles\n", 
               tctx->nbody, tctx->particle_data->count);
        free_particle_collection(tctx->particle_data);
        failed = 1;
        return failed;
    }

    // Calculate the initial density distribution for each component
    tctx->baryon_simulation_density = mwCallocA(tctx->num_bins_baryon, sizeof(real));
    tctx->dark_simulation_density = mwCallocA(tctx->num_bins_dark, sizeof(real));

    // Initialize initial densities to zero
    for (int i = 0; i < tctx->num_bins_baryon; i++) {
        tctx->baryon_simulation_density[i] = 0.0;
    }
    for (int i = 0; i < tctx->num_bins_dark; i++) {
        tctx->dark_simulation_density[i] = 0.0;
    }

    // Calculate initial densities using histogram binning
    printf("Calculating initial densities for baryon particles...\n");
    fflush(stdout);
    
    for (int i = 0; i < (int)tctx->nbody_baryon && i < (int)tctx->particle_data->count; i++) {
        real radius = mw_sqrt(
            tctx->particle_data->particles[i].x * tctx->particle_data->particles[i].x + 
            tctx->particle_data->particles[i].y * tctx->particle_data->particles[i].y + 
            tctx->particle_data->particles[i].z * tctx->particle_data->particles[i].z
        );

        // Find the bin for this radius
        for (int bin = 0; bin < tctx->num_bins_baryon; bin++) {
            if (radius >= tctx->baryon_bin_edges[bin] && radius < tctx->baryon_bin_edges[bin + 1]) {
                tctx->baryon_simulation_density[bin] += 1.0;
                break;
            }
        }
    }

    printf("Calculating initial densities for dark matter particles...\n");
    fflush(stdout);
    
    for (int i = (int)tctx->nbody_baryon; i < (int)tctx->nbody && i < (int)tctx->particle_data->count; i++) {
        real radius = mw_sqrt(
            tctx->particle_data->particles[i].x * tctx->particle_data->particles[i].x + 
            tctx->particle_data->particles[i].y * tctx->particle_data->particles[i].y + 
            tctx->particle_data->particles[i].z * tctx->particle_data->particles[i].z
        );

        // Find the bin for this radius
        for (int bin = 0; bin < tctx->num_bins_dark; bin++) {
            if (radius >= tctx->dark_bin_edges[bin] && radius < tctx->dark_bin_edges[bin + 1]) {
                tctx->dark_simulation_density[bin] += 1.0;
                break;
            }
        }
    }

    // Print sample of initial densities
    printf("Initial baryon density distribution (first 5 values): ");
    for (int i = 0; i < tctx->num_bins_baryon && i < 5; i++) {
        printf("%.6f ", tctx->baryon_simulation_density[i]);
    }
    printf("...\n");
    
    printf("Initial dark matter density distribution (first 5 values): ");
    for (int i = 0; i < tctx->num_bins_dark && i < 5; i++) {
        printf("%.6f ", tctx->dark_simulation_density[i]);
    }
    printf("...\n");
    fflush(stdout);

    // Normalize the initial densities and add epsilon to avoid division by zero and log(0) in KL divergence calculation
    tctx->baryon_simulation_probability = smooth_and_normalize_distribution(tctx->baryon_simulation_density, tctx->num_bins_baryon);
    tctx->dark_simulation_probability = smooth_and_normalize_distribution(tctx->dark_simulation_density, tctx->num_bins_dark);

    // Print sample of normalized initial densities
    printf("Initial simulation baryon probability density distribution (first 5 values): ");
    for (int i = 0; i < tctx->num_bins_baryon && i < 5; i++) {
        printf("%.6f ", tctx->baryon_simulation_probability[i]);
    }
    printf("...\n");
    
    printf("Initial simulation dark matter probability density distribution (first 5 values): ");
    for (int i = 0; i < tctx->num_bins_dark && i < 5; i++) {
        printf("%.6f ", tctx->dark_simulation_probability[i]);
    }
    printf("...\n");
    fflush(stdout);

    // Kullback-Leibler divergence for each component for the initial timestep
    real initial_kl_divergence_baryon = kl_divergence(tctx->baryon_simulation_probability, tctx->baryon_theoretical_probability, tctx->num_bins_baryon);
    real initial_kl_divergence_dark = kl_divergence(tctx->dark_simulation_probability, tctx->dark_theoretical_probability, tctx->num_bins_dark);
    printf("Initial KL divergence for baryon component: %f\n", initial_kl_divergence_baryon);
    printf("Initial KL divergence for dark matter component: %f\n", initial_kl_divergence_dark);
    fflush(stdout);
    
    // Check for negative KL divergence values (should never happen, but check explicitly)
    if (initial_kl_divergence_baryon < 0 || initial_kl_divergence_dark < 0) {
        fprintf(stderr, "Error: Negative KL divergence indicates calculation error\n");
        free_particle_collection(tctx->particle_data);
        failed = 1;
        return failed;
    }

    if (initial_kl_divergence_baryon > INITIAL_KL_THRESHOLD || initial_kl_divergence_dark > INITIAL_KL_THRESHOLD) {
        fprintf(stderr, "Error: Initial KL divergence is too high (> %f)\n", INITIAL_KL_THRESHOLD);
        fflush(stdout);
        free_particle_collection(tctx->particle_data);
        failed = 1;
        return failed;
    }

    // Free the particle collection
    free_particle_collection(tctx->particle_data);
    tctx->particle_data = NULL;
    printf("Particle collection freed successfully\n");
    fflush(stdout);

    // Calculate the total number of timesteps in the simulation 
    int total_timesteps = (int)(atof(EVOLUTION_TIME) / tctx->timestep);
    printf("Total timesteps: %d\n", total_timesteps);
    fflush(stdout);

    // Use a fixed interval of 100 timesteps
    const int timestep_interval = 100;
    printf("Checking every %d timesteps\n", timestep_interval);
    fflush(stdout);

    // Start checking from timestep 99 (after first interval)
    int first_timestep = timestep_interval - 1;
    printf("First timestep to check: %d\n", first_timestep);
    fflush(stdout);
    
    // Calculate the KL divergence at multiple timesteps
    for (int i = first_timestep; i < total_timesteps; i += timestep_interval) {
        printf("\n--- Processing timestep %d ---\n", i);
        fflush(stdout);
        
        char output_filename[1024];
        snprintf(output_filename, sizeof(output_filename), "%d", i);
        printf("Checking for output file: %s\n", output_filename);
        fflush(stdout);
        
        // Check if the output file exists
        if (access(output_filename, F_OK) == -1) {
            fprintf(stderr, "Error: Output file '%s' does not exist\n", output_filename);
            fflush(stdout);
            failed = 1;
            return failed;
        }
        
        printf("Output file exists, attempting to read...\n");
        fflush(stdout);
        
        tctx->particle_data = read_particle_file(output_filename);
        if (!tctx->particle_data) {
            fprintf(stderr, "Error: Failed to read particle file '%s'\n", output_filename);
            fflush(stdout);
            failed = 1;
            return failed;
        }

        printf("Successfully read %zu particles\n", tctx->particle_data->count);
        fflush(stdout);

        // Calculate the simulation density distribution for each component
        real* simulation_density_baryon = mwCallocA(tctx->num_bins_baryon, sizeof(real));
        real* simulation_density_dark = mwCallocA(tctx->num_bins_dark, sizeof(real));

        // Initialize simulation densities to zero
        for (int j = 0; j < tctx->num_bins_baryon; j++) {
            simulation_density_baryon[j] = 0.0;
        }
        for (int j = 0; j < tctx->num_bins_dark; j++) {
            simulation_density_dark[j] = 0.0;
        }

        // Calculate simulation densities using histogram binning
        printf("Calculating simulation densities for baryon particles...\n");
        fflush(stdout);
        
        int baryon_particles_counted = 0;
        for (int j = 0; j < (int)tctx->nbody_baryon && j < (int)tctx->particle_data->count; j++) {
            real radius = mw_sqrt(
                tctx->particle_data->particles[j].x * tctx->particle_data->particles[j].x + 
                tctx->particle_data->particles[j].y * tctx->particle_data->particles[j].y + 
                tctx->particle_data->particles[j].z * tctx->particle_data->particles[j].z
            );

            // Find the bin for this radius
            for (int bin = 0; bin < tctx->num_bins_baryon; bin++) {
                if (radius >= tctx->baryon_bin_edges[bin] && radius < tctx->baryon_bin_edges[bin + 1]) {
                    simulation_density_baryon[bin] += 1.0;
                    baryon_particles_counted++;
                    break;
                }
            }
        }

        printf("Calculating simulation densities for dark matter particles...\n");
        fflush(stdout);
        
        int dark_particles_counted = 0;
        for (int j = (int)tctx->nbody_baryon; j < (int)tctx->nbody && j < (int)tctx->particle_data->count; j++) {
            real radius = mw_sqrt(
                tctx->particle_data->particles[j].x * tctx->particle_data->particles[j].x + 
                tctx->particle_data->particles[j].y * tctx->particle_data->particles[j].y + 
                tctx->particle_data->particles[j].z * tctx->particle_data->particles[j].z
            );

            // Find the bin for this radius
            for (int bin = 0; bin < tctx->num_bins_dark; bin++) {
                if (radius >= tctx->dark_bin_edges[bin] && radius < tctx->dark_bin_edges[bin + 1]) {
                    simulation_density_dark[bin] += 1.0;
                    dark_particles_counted++;
                    break;
                }
            }
        }
        
        printf("Particles counted: %d baryon, %d dark matter\n", 
               baryon_particles_counted, dark_particles_counted);
        fflush(stdout);

        // Print sample of simulation densities
        printf("Simulation baryon density distribution (first 5 values): ");
        for (int j = 0; j < tctx->num_bins_baryon && j < 5; j++) {
            printf("%.6f ", simulation_density_baryon[j]);
        }
        printf("...\n");
        
        printf("Simulation dark matter density distribution (first 5 values): ");
        for (int j = 0; j < tctx->num_bins_dark && j < 5; j++) {
            printf("%.6f ", simulation_density_dark[j]);
        }
        printf("...\n");
        fflush(stdout);

        // Normalize the simulation densities and add epsilon to avoid division by zero and log(0) in KL divergence calculation 
        real* simulation_probability_density_baryon = smooth_and_normalize_distribution(simulation_density_baryon, tctx->num_bins_baryon);
        real* simulation_probability_density_dark = smooth_and_normalize_distribution(simulation_density_dark, tctx->num_bins_dark);

        // Print sample of normalized simulation densities
        printf("Simulation baryon probability density distribution (first 5 values): ");
        for (int j = 0; j < tctx->num_bins_baryon && j < 5; j++) {
            printf("%.6f ", simulation_probability_density_baryon[j]);
        }
        printf("...\n");
        
        printf("Simulation dark matter probability density distribution (first 5 values): ");
        for (int j = 0; j < tctx->num_bins_dark && j < 5; j++) {
            printf("%.6f ", simulation_probability_density_dark[j]);
        }
        printf("...\n");
        fflush(stdout);

        // Kullback-Leibler divergence for each component
        real kl_divergence_baryon = kl_divergence(simulation_probability_density_baryon, tctx->baryon_theoretical_probability, tctx->num_bins_baryon);
        real kl_divergence_dark = kl_divergence(simulation_probability_density_dark, tctx->dark_theoretical_probability, tctx->num_bins_dark);

        printf("KL divergence for baryon component: %f\n", kl_divergence_baryon);
        printf("KL divergence for dark matter component: %f\n", kl_divergence_dark);
        printf("Difference from initial KL divergence (baryon): %f\n", kl_divergence_baryon - initial_kl_divergence_baryon);
        printf("Difference from initial KL divergence (dark): %f\n", kl_divergence_dark - initial_kl_divergence_dark);
        fflush(stdout);

        // Check for negative KL divergence values (should never happen, but check explicitly)
        if (kl_divergence_baryon < 0 || kl_divergence_dark < 0) {
            fprintf(stderr, "Error: Negative KL divergence indicates calculation error\n");
            free(simulation_probability_density_baryon);
            free(simulation_probability_density_dark);
            free(simulation_density_baryon);
            free(simulation_density_dark);
            free_particle_collection(tctx->particle_data);
            failed = 1;
            return failed;
        }

        if ((kl_divergence_baryon - initial_kl_divergence_baryon) > KL_FLUCTUATION_THRESHOLD || 
            (kl_divergence_dark - initial_kl_divergence_dark) > KL_FLUCTUATION_THRESHOLD) {
            fprintf(stderr, "Error: KL divergence fluctuation is too high (> %f) showing instability\n", 
                   KL_FLUCTUATION_THRESHOLD);
            fflush(stdout);
            
            // Free allocated memory for this simulation iteration
            free(simulation_probability_density_baryon);
            free(simulation_probability_density_dark);
            free(simulation_density_baryon);
            free(simulation_density_dark);
            free_particle_collection(tctx->particle_data);
            failed = 1;
            return failed;
        }

        // Free allocated memory for this simulation iteration
        free(simulation_probability_density_baryon);
        free(simulation_probability_density_dark);
        free(simulation_density_baryon);
        free(simulation_density_dark);
        
        // Free data at the end of each iteration
        free_particle_collection(tctx->particle_data);
        tctx->particle_data = NULL;
        printf("Particle collection freed successfully\n");
        fflush(stdout);
    }
    
    // Free memory for probability densities
    free(tctx->baryon_simulation_probability);
    tctx->baryon_simulation_probability = NULL;
    free(tctx->dark_simulation_probability);
    tctx->dark_simulation_probability = NULL;
    
    // If we get here, all KL divergence tests passed
    printf("Stability test passed successfully!\n");
    fflush(stdout);
    
    return failed;
}

/* Computes the kinetic and potential energies and ensures that it obeys the virial theorem */
int test_virial_ratio(TestContext* tctx)
{
	int failed = 0;
	const real TOL = 0.05;

	real T  = 0; //Kinetic energy
	real U1 = 0; //Potential to be calculated using the dwarf's potential
	real U2 = 0; //potential to be calculated using newtonian gravity

	//now doing the math
	for(unsigned int i = 0; i < tctx->particle_data->count; i++)
	{
		real x  = tctx->particle_data->particles[i].x;
		real y  = tctx->particle_data->particles[i].y;
		real z  = tctx->particle_data->particles[i].z;
		real vx = tctx->particle_data->particles[i].vx;
		real vy = tctx->particle_data->particles[i].vy;
		real vz = tctx->particle_data->particles[i].vz;
		real m  = tctx->particle_data->particles[i].mass;
		
		real r = mw_sqrt(sqr(x) + sqr(y) + sqr(z));
		real v = sqr(vx) + sqr(vy) + sqr(vz);
		
		T += m * v;

		U1 += m * ( get_potential(tctx->comp1, r) + get_potential(tctx->comp2, r) );

		for(unsigned int j = i + 1; j < tctx->particle_data->count; j++)
		{
			real rij = mw_sqrt(sqr(x - tctx->particle_data->particles[j].x) + sqr(y - tctx->particle_data->particles[j].y) + sqr(z - tctx->particle_data->particles[j].z));
			U2 += 2.0 * m * tctx->particle_data->particles[j].mass / rij;
		}
	}
	T  *= 0.5;
	U1 *= 0.5;
	U2 *= 0.5;

	//Compute the ratios. These should be 1 if they are in perfect virial equilibrium
	real ratio_1 = U1 / T / 2.0;
	real ratio_2 = U2 / T / 2.0;

	if (mw_fabs(1.0 - ratio_1) > TOL)
	{
		printf("\t Virial test 1 failed, unstable structure- T: %1f U1: %1f ratio_1: %1f\n", T, U1, ratio_1);
        failed = 1;
        return failed;
	}
	if (mw_fabs(1.0 - ratio_2) > TOL)
	{
		printf("\tVirial test 2 failed, gravitationally unstable- T: %1f U2: %1f ratio_2: %1f\n", T, U2, ratio_2);
        failed = 1;
        return failed;
	}

    printf("\tPassed virial test\n");
    fflush(stdout);
	
	//printf("T: %1f, U1: %1f U2: %1f ratio_1: %1f ratio_2: %1f\n", T, U1, U2, ratio_1, ratio_2);

	return failed;

}

/* This function checks to ensure that the 2 components are individually and the dwarf as a whole are centered at 0 */
int test_center_of_mass(TestContext* tctx)
{
	//Note, this function relies on the fact that half the bodies are baryonic and half dark matter
	int failed = 0;
	const real TOL = 0.000001;

	real totalMass_l = tctx->comp1->mass;
	real totalMass_d = tctx->comp2->mass;
	real totalMass = totalMass_l + totalMass_d;
	
	real cm_x_comp1  = 0.0;
    real cm_y_comp1  = 0.0;
    real cm_z_comp1  = 0.0;
    real cm_vx_comp1 = 0.0;
    real cm_vy_comp1 = 0.0;
    real cm_vz_comp1 = 0.0;

	real cm_x_comp2  = 0.0;
    real cm_y_comp2  = 0.0;
    real cm_z_comp2  = 0.0;
    real cm_vx_comp2 = 0.0;
    real cm_vy_comp2 = 0.0;
    real cm_vz_comp2 = 0.0;

	for(unsigned int i = 0; i < tctx->nbody_baryon; i++)
	{
		cm_x_comp1 += tctx->particle_data->particles[i].mass * tctx->particle_data->particles[i].x;
		cm_y_comp1 += tctx->particle_data->particles[i].mass * tctx->particle_data->particles[i].y;
		cm_z_comp1 += tctx->particle_data->particles[i].mass * tctx->particle_data->particles[i].z;

		cm_vx_comp1 += tctx->particle_data->particles[i].mass * tctx->particle_data->particles[i].vx;
		cm_vy_comp1 += tctx->particle_data->particles[i].mass * tctx->particle_data->particles[i].vy;
		cm_vz_comp1 += tctx->particle_data->particles[i].mass * tctx->particle_data->particles[i].vz;
	}

	for(unsigned int i = tctx->nbody_baryon; i < tctx->nbody; i++)
	{
		cm_x_comp2 += tctx->particle_data->particles[i].mass * tctx->particle_data->particles[i].x;
		cm_y_comp2 += tctx->particle_data->particles[i].mass * tctx->particle_data->particles[i].y;
		cm_z_comp2 += tctx->particle_data->particles[i].mass * tctx->particle_data->particles[i].z;

		cm_vx_comp2 += tctx->particle_data->particles[i].mass * tctx->particle_data->particles[i].vx;
		cm_vy_comp2 += tctx->particle_data->particles[i].mass * tctx->particle_data->particles[i].vy;
		cm_vz_comp2 += tctx->particle_data->particles[i].mass * tctx->particle_data->particles[i].vz;
	}

	cm_x_comp1 /= totalMass_l;
	cm_y_comp1 /= totalMass_l;
	cm_z_comp1 /= totalMass_l;
	
	cm_vx_comp1 /= totalMass_l;
	cm_vy_comp1 /= totalMass_l;
	cm_vz_comp1 /= totalMass_l;
	
	if(mw_fabs(cm_x_comp1) > TOL || mw_fabs(cm_y_comp1) > TOL || mw_fabs(cm_z_comp1) > TOL
		|| mw_fabs(cm_vx_comp1) > TOL || mw_fabs(cm_vy_comp1) > TOL || mw_fabs(cm_vz_comp1) > TOL)
	{
		printf("\tFailed: Component 1 is off center, cm_x: %1f cm_y: %1f cm_z: %1f cm_vx: %1f cm_vy: %1f cm_z: %1f\n",
		cm_x_comp1, cm_y_comp1, cm_z_comp1, cm_vx_comp1, cm_vy_comp1, cm_vz_comp1);
        failed = 1;
        return failed;
	}

	cm_x_comp2 /= totalMass_d;
	cm_y_comp2 /= totalMass_d;
	cm_z_comp2 /= totalMass_d;
	
	cm_vx_comp2 /= totalMass_d;
	cm_vy_comp2 /= totalMass_d;
	cm_vz_comp2 /= totalMass_d;
	
	if(mw_fabs(cm_x_comp2) > TOL || mw_fabs(cm_y_comp2) > TOL || mw_fabs(cm_z_comp2) > TOL
		|| mw_fabs(cm_vx_comp2) > TOL || mw_fabs(cm_vy_comp2) > TOL || mw_fabs(cm_vz_comp2) > TOL)
	{
		printf("\tFailed: Component 2 is off center, cm_x: %1f cm_y: %1f cm_z: %1f cm_vx: %1f cm_vy: %1f cm_z: %1f\n",
		cm_x_comp2, cm_y_comp2, cm_z_comp2, cm_vx_comp2, cm_vy_comp2, cm_vz_comp2);
        failed = 1;
        return failed;
	}

	real cm_x_total = (cm_x_comp1 + cm_x_comp2) / totalMass;
	real cm_y_total = (cm_y_comp1 + cm_y_comp2) / totalMass;
	real cm_z_total = (cm_z_comp1 + cm_z_comp2) / totalMass;
	
	real cm_vx_total = (cm_vx_comp1 + cm_vx_comp2) / totalMass;
	real cm_vy_total = (cm_vy_comp1 + cm_vy_comp2) / totalMass;
	real cm_vz_total = (cm_vz_comp1 + cm_vz_comp2) / totalMass;

	if(mw_fabs(cm_x_total) > TOL || mw_fabs(cm_y_total) > TOL || mw_fabs(cm_z_total) > TOL
		|| mw_fabs(cm_vx_total) > TOL || mw_fabs(cm_vy_total) > TOL || mw_fabs(cm_vz_total) > TOL)
	{
		printf("\tFailed: Total Dwarf is off center, cm_x: %1f cm_y: %1f cm_z: %1f cm_vx: %1f cm_vy: %1f cm_z: %1f\n",
		cm_x_total, cm_y_total, cm_z_total, cm_vx_total, cm_vy_total, cm_vz_total);
        failed = 1;
        return failed;
	}

    printf("\tPassed center of mass test\n");
    fflush(stdout);
	return failed;
}

/* Run the nbody simulation for a given dwarf potential type */
int run_nbody_simulation(const char* dwarf_potential_type_lua, TestContext* tctx) {
    if (!tctx) return 1;
    memset(tctx, 0, sizeof(TestContext));
    int failed = 0;
    const char* dwarf_params[] = {
        EVOLUTION_TIME,
        EVOLUTION_RATIO,
        BARYON_SCALE_RADIUS,
        SCALE_RADIUS_RATIO,
        BARYON_MASS,
        MASS_RATIO
    };
    // Clean up any output files from previous runs
    printf("Cleaning up any output files from previous runs...\n");
    fflush(stdout);
    const char* initial_output_file = "initial.out";
    remove(initial_output_file); // Ignore errors
    char output_filename[1024];
    for (int i = 0; i < 10000; i++) {
        snprintf(output_filename, sizeof(output_filename), "%d", i);
        remove(output_filename); // Ignore errors
    }
    const char* final_output_files[] = {"output.out", "output.hist"};
    for (int i = 0; i < 2; i++) {
        remove(final_output_files[i]); // Ignore errors
    }
    // Find the lua file
    tctx->input_lua_file = find_lua_file(dwarf_potential_type_lua);
    if (!tctx->input_lua_file) {
        fprintf(stderr, "Error: Could not find %s.lua in any expected location\n", dwarf_potential_type_lua);
        failed = 1;
        return failed;
    }
    printf("Input file path: %s\n", tctx->input_lua_file);
    fflush(stdout);
    // Read the parameters from the Lua file
    printf("Reading Lua parameters...\n");
    fflush(stdout);
    if (read_lua_parameters(tctx->input_lua_file, dwarf_params, &tctx->nbody, &tctx->nbody_baryon, &tctx->comp1, &tctx->comp2, &tctx->timestep, NULL) != 0) {
        fprintf(stderr, "Error: Failed to read Lua parameters\n");
        fflush(stdout);
        failed = 1;
        return failed;
    }
    // Run a simulation
    printf("Running N-body simulation...\n");
    fflush(stdout);
    if (run_nbody(dwarf_params, tctx->input_lua_file) != 0) {
        fprintf(stderr, "Error: N-body simulation failed\n");
        fflush(stdout);
        failed = 1;
        return failed;
    }
    printf("N-body simulation completed successfully\n");
    fflush(stdout);
    return failed;
}

int main() {

    int total_failed = 0;

    // List of dwarf models to test
    const char* dwarf_models[] = {
        "plummer_plummer.lua",
        "plummer_nfw.lua",
        "plummer_hernquist.lua",
        "plummer_cored.lua",
    };

    // Number of models to test
    int num_models = sizeof(dwarf_models) / sizeof(dwarf_models[0]);

    // Test each model
    for (int i = 0; i < num_models; i++) {
        int failed = 0;
        printf("\n=== Testing %s ===\n", dwarf_models[i]);
        TestContext tctx;
        memset(&tctx, 0, sizeof(TestContext)); 
        // Run the N-body simulation and fill context
        if (run_nbody_simulation(dwarf_models[i], &tctx) != 0) {
            fprintf(stderr, "Error: N-body simulation failed\n");
            fflush(stdout);
            failed = 1;
            cleanup_all_memory(&tctx);
            return failed; 
        }
        failed += test_stability(&tctx);
        // Reload particle data for subsequent tests
        tctx.particle_data = read_particle_file("initial.out");
        if (!tctx.particle_data) {
            fprintf(stderr, "Error: Failed to read initial.out for further tests\n");
            fflush(stdout);
            failed = 1;
            cleanup_all_memory(&tctx);
            return failed;
        }
        failed += test_virial_ratio(&tctx);
        failed += test_center_of_mass(&tctx);
        free_particle_collection(tctx.particle_data);
        tctx.particle_data = NULL;
        if (failed == 0) {
            printf("%s passed all tests!\n", dwarf_models[i]);
        } else {
            printf("%s failed %d tests!\n", dwarf_models[i], failed);
            total_failed += failed;
        }
        cleanup_all_memory(&tctx);
    }
    if(total_failed == 0)
    {
        printf("\n=== SUMMARY ===\n");
        printf("All dwarf generation tests successful!\n");
    }
    else
    {
        printf("\n=== SUMMARY ===\n");
        printf("Failed %d tests across all models\n", total_failed);
    }
    return total_failed > 0 ? 1 : 0;
}